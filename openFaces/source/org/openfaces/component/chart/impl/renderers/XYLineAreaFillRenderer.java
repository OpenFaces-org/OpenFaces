/*
 * OpenFaces - JSF Component Library 2.0
 * Copyright (C) 2007-2010, TeamDev Ltd.
 * licensing@openfaces.org
 * Unless agreed in writing the contents of this file are subject to
 * the GNU Lesser General Public License Version 2.1 (the "LGPL" License).
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * Please visit http://openfaces.org/licensing/ for more details.
 */

package org.openfaces.component.chart.impl.renderers;

import org.jfree.chart.LegendItem;
import org.jfree.chart.axis.CategoryAxis;
import org.jfree.chart.axis.ValueAxis;
import org.jfree.chart.entity.EntityCollection;
import org.jfree.chart.plot.CategoryPlot;
import org.jfree.chart.plot.CrosshairState;
import org.jfree.chart.plot.PlotOrientation;
import org.jfree.chart.plot.PlotRenderingInfo;
import org.jfree.chart.plot.XYPlot;
import org.jfree.chart.renderer.category.CategoryItemRendererState;
import org.jfree.chart.renderer.xy.AbstractXYItemRenderer;
import org.jfree.chart.renderer.xy.XYItemRenderer;
import org.jfree.chart.renderer.xy.XYItemRendererState;
import org.jfree.data.category.CategoryDataset;
import org.jfree.data.xy.XYDataset;
import org.jfree.io.SerialUtilities;
import org.jfree.util.BooleanList;
import org.jfree.util.BooleanUtilities;
import org.jfree.util.ObjectUtilities;
import org.jfree.util.PublicCloneable;
import org.jfree.util.ShapeUtilities;
import org.openfaces.component.chart.GradientLineAreaFill;
import org.openfaces.component.chart.LineAreaFill;
import org.openfaces.component.chart.LineChartView;
import org.openfaces.component.chart.SolidLineAreaFill;

import java.awt.*;
import java.awt.geom.Line2D;
import java.awt.geom.Rectangle2D;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.util.ArrayList;
import java.util.Collection;

/**
 * Area item renderer for an {@link org.jfree.chart.plot.XYPlot}.  This class can draw (a) shapes at
 * each point, or (b) lines between points, or (c) both shapes and lines,
 * or (d) filled areas, or (e) filled areas and shapes. The example shown here
 * is generated by the <code>XYAreaRendererDemo1.java</code> program included
 * in the JFreeChart demo collection:
 * <br><br>
 * <img src="../../../../../images/XYAreaRendererSample.png"
 * alt="XYAreaRendererSample.png" />
 */
public class XYLineAreaFillRenderer extends AbstractXYItemRenderer
        implements XYItemRenderer, PublicCloneable, XYRendererAdapter, AreaFillRenderer, CustomizedRenderer  {
     private ItemsRenderer delegate;

    /**
     * For serialization.
     */
    private static final long serialVersionUID = -4481971353973886747L;

    /**
     * A state object used by this renderer.
     */
    static class XYLineAreaFillRendererState extends XYItemRendererState {

        /**
         * Working storage for the area under one series.
         */
        public Polygon area;

        /**
         * Working line that can be recycled.
         */
        public Line2D line;

        public Collection<Line2D.Double> lines;

        /**
         * Creates a new state.
         *
         * @param info the plot rendering info.
         */
        public XYLineAreaFillRendererState(PlotRenderingInfo info) {
            super(info);
            this.area = new Polygon();
            this.line = new Line2D.Double();
            this.lines = new ArrayList<Line2D.Double>();
        }

    }

    /**
     * A table of flags that control (per series) whether or not shapes are
     * visible.
     */
    private BooleanList seriesShapesVisible;

    /**
     * The default value returned by the getShapeVisible() method.
     */
    private boolean baseShapesVisible;

    /**
     * A table of flags that control (per series) whether or not lines are
     * visible.
     */
    private BooleanList seriesLinesVisible;

    /**
     * The default value returned by the getLinesVisible() method.
     */
    private boolean baseLinesVisible;

    /**
     * The shape that is used to represent a line in the legend.
     */
    private transient Shape legendLine;

    /**
     * A table of flags that control (per series) whether or not shapes are
     * filled.
     */
    private BooleanList seriesShapesFilled;

    /**
     * The default value returned by the getShapeFilled() method.
     */
    private boolean baseShapesFilled;

    /**
     * A flag that controls whether the fill paint is used for filling
     * shapes.
     */
    private boolean useFillPaint;

    /**
     * A flag that controls whether the outline paint is used for drawing shape
     * outlines.
     */
    private boolean useOutlinePaint;

    /**
     * A flag indicating whether or not Area are drawn at each XY point.
     */
    private boolean drawFilledArea;

    /**
     * A flag that controls whether or not the outline is shown.
     */
    private boolean drawOutlines;

    private Paint backgroundPaint;

    private LineAreaFill lineAreaFill;

    /**
     * Constructs a new renderer.
     */
    public XYLineAreaFillRenderer() {
        this(true, true);
    }

    public XYLineAreaFillRenderer(LineChartView chartView, XYDataset dataSet) {
        this(true, true);
        delegate = new ItemsRenderer();
        ChartRendering.setupSeriesColors(chartView, this);
        ChartRendering.processXYLineAndShapeRendererProperties(this, dataSet, chartView);
    }

    /**
     * Constructs a new renderer.
     *
     * @param lines
     * @param shapes
     */
    public XYLineAreaFillRenderer(boolean lines, boolean shapes) {
        super();

        this.seriesLinesVisible = new BooleanList();
        this.baseLinesVisible = lines;
        this.legendLine = new Line2D.Double(-7.0, 0.0, 7.0, 0.0);

        this.seriesShapesVisible = new BooleanList();
        this.baseShapesVisible = shapes;

        this.useFillPaint = false;     // use item paint for fills by default
        this.seriesShapesFilled = new BooleanList();
        this.baseShapesFilled = true;

        this.drawFilledArea = true;
        this.drawOutlines = false;
        this.useOutlinePaint = false;
        // use item paint for outlines by
        // default, not outline paint
    }

    /**
     * Returns the number of passes through the data that the renderer requires
     * in order to draw the chart.  Most charts will require a single pass, but
     * some require two passes.
     *
     * @return The pass count.
     */
    public int getPassCount() {
        return 2;
    }

    public Paint getBackgroundPaint() {
        return backgroundPaint;
    }

    public void setBackgroundPaint(Paint backgroundPaint) {
        this.backgroundPaint = backgroundPaint;
    }

    public LineAreaFill getLineAreaFill() {
        return lineAreaFill;
    }

    public void setLineAreaFill(LineAreaFill lineAreaFill) {
        this.lineAreaFill = lineAreaFill;
    }

    // LINES VISIBLE

    /**
     * Returns the flag used to control whether or not the shape for an item is
     * visible.
     *
     * @param series the series index (zero-based).
     * @param item   the item index (zero-based).
     * @return A boolean.
     */
    public boolean getItemLineVisible(int series, int item) {
        Boolean flag = getSeriesLinesVisible(series);

        if (flag != null) {
            return flag.booleanValue();
        } else {
            return this.baseLinesVisible;
        }
    }

    /**
     * Returns the flag used to control whether or not the lines for a series
     * are visible.
     *
     * @param series the series index (zero-based).
     * @return The flag (possibly <code>null</code>).
     * @see #setSeriesLinesVisible(int, Boolean)
     */
    public Boolean getSeriesLinesVisible(int series) {
        return this.seriesLinesVisible.getBoolean(series);
    }

    /**
     * Sets the 'lines visible' flag for a series and sends a
     * {@link org.jfree.chart.event.RendererChangeEvent} to all registered listeners.
     *
     * @param series the series index (zero-based).
     * @param flag   the flag (<code>null</code> permitted).
     * @see #getSeriesLinesVisible(int)
     */
    public void setSeriesLinesVisible(int series, Boolean flag) {
        this.seriesLinesVisible.setBoolean(series, flag);
        fireChangeEvent();
    }

    /**
     * Sets the 'lines visible' flag for a series and sends a
     * {@link org.jfree.chart.event.RendererChangeEvent} to all registered listeners.
     *
     * @param series  the series index (zero-based).
     * @param visible the flag.
     * @see #getSeriesLinesVisible(int)
     */
    public void setSeriesLinesVisible(int series, boolean visible) {
        setSeriesLinesVisible(series, BooleanUtilities.valueOf(visible));
    }

    /**
     * Returns the base 'lines visible' attribute.
     *
     * @return The base flag.
     * @see #setBaseLinesVisible(boolean)
     */
    public boolean getBaseLinesVisible() {
        return this.baseLinesVisible;
    }

    /**
     * Sets the base 'lines visible' flag and sends a
     * {@link org.jfree.chart.event.RendererChangeEvent} to all registered listeners.
     *
     * @param flag the flag.
     * @see #getBaseLinesVisible()
     */
    public void setBaseLinesVisible(boolean flag) {
        this.baseLinesVisible = flag;
        fireChangeEvent();
    }

    /**
     * Returns the shape used to represent a line in the legend.
     *
     * @return The legend line (never <code>null</code>).
     * @see #setLegendLine(Shape)
     */
    public Shape getLegendLine() {
        return this.legendLine;
    }

    /**
     * Sets the shape used as a line in each legend item and sends a
     * {@link org.jfree.chart.event.RendererChangeEvent} to all registered listeners.
     *
     * @param line the line (<code>null</code> not permitted).
     * @see #getLegendLine()
     */
    public void setLegendLine(Shape line) {
        if (line == null) {
            throw new IllegalArgumentException("Null 'line' argument.");
        }
        this.legendLine = line;
        fireChangeEvent();
    }

    // SHAPES VISIBLE

    /**
     * Returns the flag used to control whether or not the shape for an item is
     * visible.
     * <p/>
     * The default implementation passes control to the
     * <code>getSeriesShapesVisible</code> method. You can override this method
     * if you require different behaviour.
     *
     * @param series the series index (zero-based).
     * @param item   the item index (zero-based).
     * @return A boolean.
     */
    public boolean getItemShapeVisible(int series, int item) {
        Boolean flag = getSeriesShapesVisible(series);

        if (flag != null) {
            return flag.booleanValue();
        } else {
            return this.baseShapesVisible;
        }
    }

    /**
     * Returns the flag used to control whether or not the shapes for a series
     * are visible.
     *
     * @param series the series index (zero-based).
     * @return A boolean.
     * @see #setSeriesShapesVisible(int, Boolean)
     */
    public Boolean getSeriesShapesVisible(int series) {
        return this.seriesShapesVisible.getBoolean(series);
    }

    /**
     * Sets the 'shapes visible' flag for a series and sends a
     * {@link org.jfree.chart.event.RendererChangeEvent} to all registered listeners.
     *
     * @param series  the series index (zero-based).
     * @param visible the flag.
     * @see #getSeriesShapesVisible(int)
     */
    public void setSeriesShapesVisible(int series, boolean visible) {
        setSeriesShapesVisible(series, BooleanUtilities.valueOf(visible));
    }

    /**
     * Sets the 'shapes visible' flag for a series and sends a
     * {@link org.jfree.chart.event.RendererChangeEvent} to all registered listeners.
     *
     * @param series the series index (zero-based).
     * @param flag   the flag.
     * @see #getSeriesShapesVisible(int)
     */
    public void setSeriesShapesVisible(int series, Boolean flag) {
        this.seriesShapesVisible.setBoolean(series, flag);
        fireChangeEvent();
    }

    /**
     * Returns the base 'shape visible' attribute.
     *
     * @return The base flag.
     * @see #setBaseShapesVisible(boolean)
     */
    public boolean getBaseShapesVisible() {
        return this.baseShapesVisible;
    }

    /**
     * Sets the base 'shapes visible' flag and sends a
     * {@link org.jfree.chart.event.RendererChangeEvent} to all registered listeners.
     *
     * @param flag the flag.
     * @see #getBaseShapesVisible()
     */
    public void setBaseShapesVisible(boolean flag) {
        this.baseShapesVisible = flag;
        fireChangeEvent();
    }

    // SHAPES FILLED

    /**
     * Returns the flag used to control whether or not the shape for an item
     * is filled.
     * <p/>
     * The default implementation passes control to the
     * <code>getSeriesShapesFilled</code> method. You can override this method
     * if you require different behaviour.
     *
     * @param series the series index (zero-based).
     * @param item   the item index (zero-based).
     * @return A boolean.
     */
    public boolean getItemShapeFilled(int series, int item) {
        Boolean flag = getSeriesShapesFilled(series);

        if (flag != null) {
            return flag;
        } else {
            return this.baseShapesFilled;
        }
    }

    /**
     * Returns the flag used to control whether or not the shapes for a series
     * are filled.
     *
     * @param series the series index (zero-based).
     * @return A boolean.
     * @see #setSeriesShapesFilled(int, Boolean)
     */
    public Boolean getSeriesShapesFilled(int series) {
        return this.seriesShapesFilled.getBoolean(series);
    }

    /**
     * Sets the 'shapes filled' flag for a series and sends a
     * {@link org.jfree.chart.event.RendererChangeEvent} to all registered listeners.
     *
     * @param series the series index (zero-based).
     * @param flag   the flag.
     * @see #getSeriesShapesFilled(int)
     */
    public void setSeriesShapesFilled(int series, boolean flag) {
        setSeriesShapesFilled(series, BooleanUtilities.valueOf(flag));
    }

    /**
     * Sets the 'shapes filled' flag for a series and sends a
     * {@link org.jfree.chart.event.RendererChangeEvent} to all registered listeners.
     *
     * @param series the series index (zero-based).
     * @param flag   the flag.
     * @see #getSeriesShapesFilled(int)
     */
    public void setSeriesShapesFilled(int series, Boolean flag) {
        this.seriesShapesFilled.setBoolean(series, flag);
        fireChangeEvent();
    }

    /**
     * Returns the base 'shape filled' attribute.
     *
     * @return The base flag.
     * @see #setBaseShapesFilled(boolean)
     */
    public boolean getBaseShapesFilled() {
        return this.baseShapesFilled;
    }

    /**
     * Sets the base 'shapes filled' flag and sends a
     * {@link org.jfree.chart.event.RendererChangeEvent} to all registered listeners.
     *
     * @param flag the flag.
     * @see #getBaseShapesFilled()
     */
    public void setBaseShapesFilled(boolean flag) {
        this.baseShapesFilled = flag;
        fireChangeEvent();
    }

    /**
     * Returns <code>true</code> if the renderer should use the fill paint
     * setting to fill shapes, and <code>false</code> if it should just
     * use the regular paint.
     * <p/>
     * Refer to <code>XYLineAndShapeRendererDemo2.java</code> to see the
     * effect of this flag.
     *
     * @return A boolean.
     * @see #setUseFillPaint(boolean)
     * @see #getUseOutlinePaint()
     */
    public boolean getUseFillPaint() {
        return this.useFillPaint;
    }

    /**
     * Sets the flag that controls whether the fill paint is used to fill
     * shapes, and sends a {@link org.jfree.chart.event.RendererChangeEvent} to all
     * registered listeners.
     *
     * @param flag the flag.
     * @see #getUseFillPaint()
     */
    public void setUseFillPaint(boolean flag) {
        this.useFillPaint = flag;
        fireChangeEvent();
    }

    /**
     * Returns a flag that controls whether or not outlines of the areas are
     * drawn.
     *
     * @return The flag.
     * @see #setDrawOutlines(boolean)
     */
    public boolean getDrawOutlines() {
        return this.drawOutlines;
    }

    /**
     * Sets a flag that controls whether or not outlines of the areas are drawn
     * and sends a {@link org.jfree.chart.event.RendererChangeEvent} to all registered listeners.
     *
     * @param show the flag.
     * @see #getDrawOutlines()
     */
    public void setDrawOutlines(boolean show) {
        this.drawOutlines = show;
        fireChangeEvent();
    }

    /**
     * Returns <code>true</code> if the renderer should use the outline paint
     * setting to draw shape outlines, and <code>false</code> if it should just
     * use the regular paint.
     *
     * @return A boolean.
     * @see #setUseOutlinePaint(boolean)
     * @see #getUseFillPaint()
     */
    public boolean getUseOutlinePaint() {
        return this.useOutlinePaint;
    }

    /**
     * Sets the flag that controls whether the outline paint is used to draw
     * shape outlines, and sends a {@link org.jfree.chart.event.RendererChangeEvent} to all
     * registered listeners.
     * <p/>
     * Refer to <code>XYLineAndShapeRendererDemo2.java</code> to see the
     * effect of this flag.
     *
     * @param flag the flag.
     * @see #getUseOutlinePaint()
     */
    public void setUseOutlinePaint(boolean flag) {
        this.useOutlinePaint = flag;
        fireChangeEvent();
    }

    /**
     * Returns true if Area is being plotted by the renderer.
     *
     * @return <code>true</code> if Area is being plotted by the renderer.
     */
    public boolean isDrawFilledArea() {
        return this.drawFilledArea;
    }

    public void setDrawFilledArea(boolean drawFilledArea) {
        this.drawFilledArea = drawFilledArea;
    }

    /**
     * Initialises the renderer and returns a state object that should be
     * passed to all subsequent calls to the drawItem() method.
     *
     * @param g2       the graphics device.
     * @param dataArea the area inside the axes.
     * @param plot     the plot.
     * @param data     the data.
     * @param info     an optional info collection object to return data back to
     *                 the caller.
     * @return A state object for use by the renderer.
     */
    public XYItemRendererState initialise(Graphics2D g2, Rectangle2D dataArea,
                                          XYPlot plot, XYDataset data, PlotRenderingInfo info) {
        XYLineAreaFillRendererState state = new XYLineAreaFillRendererState(info);

        // in the rendering process, there is special handling for item
        // zero, so we can't support processing of visible data items only
        state.setProcessVisibleItemsOnly(false);
        return state;
    }

    /**
     * Returns a legend item for the specified series.
     *
     * @param dataSetIndex the dataset index (zero-based).
     * @param series       the series index (zero-based).
     * @return A legend item for the series.
     */
    public LegendItem getLegendItem(int dataSetIndex, int series) {

        XYPlot plot = getPlot();
        if (plot == null) {
            return null;
        }

        LegendItem result = null;
        XYDataset dataSet = plot.getDataset(dataSetIndex);
        if (dataSet != null) {
            if (getItemVisible(series, 0)) {
                String label = getLegendItemLabelGenerator().generateLabel(dataSet, series);
                String toolTipText = null;
                if (getLegendItemToolTipGenerator() != null) {
                    toolTipText = getLegendItemToolTipGenerator().generateLabel(dataSet, series);
                }

                String urlText = null;
                if (getLegendItemURLGenerator() != null) {
                    urlText = getLegendItemURLGenerator().generateLabel(dataSet, series);
                }

                boolean shapeIsVisible = getItemShapeVisible(series, 0);
                Shape shape = lookupLegendShape(series);
                boolean shapeIsFilled = getItemShapeFilled(series, 0);
                Paint fillPaint = (this.useFillPaint
                        ? lookupSeriesFillPaint(series)
                        : lookupSeriesPaint(series));

                boolean shapeOutlineVisible = this.drawOutlines;
                Paint outlinePaint = (this.useOutlinePaint
                        ? lookupSeriesOutlinePaint(series)
                        : lookupSeriesPaint(series));
                Stroke outlineStroke = lookupSeriesOutlineStroke(series);
                boolean lineVisible = getItemLineVisible(series, 0);
                Stroke lineStroke = lookupSeriesStroke(series);
                Paint linePaint = lookupSeriesPaint(series);

                result = new LegendItem(label, label, toolTipText,
                        urlText, shapeIsVisible, shape, shapeIsFilled,
                        fillPaint, shapeOutlineVisible, outlinePaint,
                        outlineStroke, lineVisible, this.legendLine,
                        lineStroke, linePaint);
                result.setLabelFont(lookupLegendTextFont(series));
                Paint labelPaint = lookupLegendTextPaint(series);
                if (labelPaint != null) {
                    result.setLabelPaint(labelPaint);
                }
                result.setSeriesKey(dataSet.getSeriesKey(series));
                result.setSeriesIndex(series);
                result.setDataset(dataSet);
                result.setDatasetIndex(dataSetIndex);
            }
        }

        return result;

    }

    /**
     * Draws the visual representation of a single data item.
     *
     * @param g2             the graphics device.
     * @param state          the renderer state.
     * @param dataArea       the area within which the data is being drawn.
     * @param info           collects information about the drawing.
     * @param plot           the plot (can be used to obtain standard color information
     *                       etc).
     * @param domainAxis     the domain axis.
     * @param rangeAxis      the range axis.
     * @param dataSet        the dataSet.
     * @param series         the series index (zero-based).
     * @param item           the item index (zero-based).
     * @param crosshairState crosshair information for the plot
     *                       (<code>null</code> permitted).
     * @param pass           the pass index.
     */
    public void drawItem(Graphics2D g2, XYItemRendererState state,
                         Rectangle2D dataArea, PlotRenderingInfo info, XYPlot plot,
                         ValueAxis domainAxis, ValueAxis rangeAxis, XYDataset dataSet,
                         int series, int item, CrosshairState crosshairState, int pass) {
        if (!getItemVisible(series, item)) {
            return;
        }

        final double xValue = dataSet.getXValue(series, item);
        final double yValue = dataSet.getYValue(series, item);
        if (Double.isNaN(yValue) || Double.isNaN(xValue)) {
            return;
        }

        XYLineAreaFillRendererState rendererState = (XYLineAreaFillRendererState) state;
        final PlotOrientation orientation = plot.getOrientation();
        final boolean isVerticallyOrientedPlot = orientation == PlotOrientation.VERTICAL;
        final boolean isHorizontallyOrientedPlot = orientation == PlotOrientation.HORIZONTAL;

        final int seriesItemsCount = dataSet.getItemCount(series);
        final int previousItemIndex = Math.max(item - 1, 0);
        final int nextItemIndex = Math.min(item + 1, seriesItemsCount - 1);
        final boolean isFirstItem = item == 0;
        // Check if the item is the last item for the series.
        // and number of items > 0.  We can't draw an area for a single point.
        final boolean isLastItem = item == (seriesItemsCount - 1);
        final boolean areaCanBeDrawn = !isFirstItem && isLastItem;

        // get the data point...
        double currentItemX = calculateItemXPoint(series, item, dataArea, domainAxis, dataSet, plot);
        double currentItemY = calculateItemYPoint(series, item, dataArea, rangeAxis, dataSet, plot);
        // get the previous point and the next point so we can calculate a
        // "hot spot" for the area (used by the chart entity)...
        double previousItemX = calculateItemXPoint(series, previousItemIndex, dataArea, domainAxis, dataSet, plot);
        double previousItemY = calculateItemYPoint(series, previousItemIndex, dataArea, rangeAxis, dataSet, plot);
        double nextItemX = calculateItemXPoint(series, nextItemIndex, dataArea, domainAxis, dataSet, plot);
        double nextItemY = calculateItemYPoint(series, nextItemIndex, dataArea, rangeAxis, dataSet, plot);
        // the first point is (x, 0)
        double zeroRangePoint = rangeAxis.valueToJava2D(0.0, dataArea, plot.getRangeAxisEdge());

        if (isAreaAndLinePass(pass)) {
            if (isFirstItem) {
                rendererState.lines = new ArrayList<Line2D.Double>();
                // create a new area polygon for the series
                rendererState.area = new Polygon();

                if (isVerticallyOrientedPlot) {
                    rendererState.area.addPoint((int) currentItemX, (int) zeroRangePoint);
                } else if (isHorizontallyOrientedPlot) {
                    rendererState.area.addPoint((int) zeroRangePoint, (int) currentItemX);
                }
            }

            // Add each point to Area (x, y)
            if (isVerticallyOrientedPlot) {
                rendererState.area.addPoint((int) currentItemX, (int) currentItemY);
            } else if (isHorizontallyOrientedPlot) {
                rendererState.area.addPoint((int) currentItemY, (int) currentItemX);
            }

            if (isDrawFilledArea() && areaCanBeDrawn) {
                if (isVerticallyOrientedPlot) {
                    // Add the last point (x,0)
                    rendererState.area.addPoint((int) currentItemX, (int) zeroRangePoint);
                } else if (isHorizontallyOrientedPlot) {
                    // Add the last point (x,0)
                    rendererState.area.addPoint((int) zeroRangePoint, (int) currentItemX);
                }

                final double plotWidth = info.getPlotArea().getWidth();
                final double plotHeight = info.getPlotArea().getHeight();

                final Paint itemPaint = getItemPaint(series, item);
                final LineAreaFill areaFill = getLineAreaFill();

                if (areaFill instanceof SolidLineAreaFill) {
                    SolidLineAreaFill solidLineAreaFill = (SolidLineAreaFill) areaFill;
                    final Double transparency = solidLineAreaFill.getTransparency();

                    if (itemPaint instanceof Color) {
                        Color itemColor = (Color) itemPaint;
                        int alpha = transparency >= 0.0 && transparency <= 1.0
                                ? Math.round(255 * transparency.floatValue())
                                : 255;
                        g2.setPaint(new Color(itemColor.getRed(), itemColor.getGreen(), itemColor.getBlue(), alpha));
                    } else {
                        g2.setPaint(itemPaint);
                    }
                } else if (areaFill instanceof GradientLineAreaFill) {
                    GradientLineAreaFill gradientLineAreaFill = (GradientLineAreaFill) areaFill;
                    final Double mainColorTransparency = gradientLineAreaFill.getMaxValueTransparency();
                    final Double bgColorTransparency = gradientLineAreaFill.getMinValueTransparency();

                    if (itemPaint instanceof Color) {
                        final Color itemColor = (Color) itemPaint;
                        final int red = itemColor.getRed();
                        final int green = itemColor.getGreen();
                        final int blue = itemColor.getBlue();
                        int mainColorAlpha = (mainColorTransparency >= 0.0 && mainColorTransparency <= 1.0)
                                ? Math.round(255 * mainColorTransparency.floatValue())
                                : 150;
                        int bgColorAlpha = (bgColorTransparency >= 0.0 && bgColorTransparency <= 1.0)
                                ? Math.round(255 * bgColorTransparency.floatValue())
                                : 128;

                        final Color mainColor = new Color(red, green, blue, mainColorAlpha);
                        final Paint bgColor = getBackgroundPaint();

                        final Color secondaryColor = (bgColor != null && bgColor instanceof Color)
                                ? new Color(((Color) bgColor).getRed(), ((Color) bgColor).getGreen(), ((Color) bgColor).getBlue(), bgColorAlpha)
                                : new Color(0, 0, 0, bgColorAlpha);

                        Paint areaPaint = (plot.getOrientation() == PlotOrientation.VERTICAL)
                                ? new GradientPaint(0.0f, 0.0f, mainColor, 0.0f, new Double(plotHeight).floatValue(), secondaryColor, true)
                                : new GradientPaint(new Double(plotWidth).floatValue(), 0.0f, mainColor, 0.0f, 0.0f, secondaryColor, true);

                        g2.setPaint(areaPaint);
                    } else {
                        g2.setPaint(itemPaint);
                    }
                }

                g2.fill(rendererState.area);
            }

            if (getItemLineVisible(series, item) && !isFirstItem) {
                addItemLine(plot, rendererState, previousItemX, previousItemY, currentItemX, currentItemY);

                if (isLastItem) {
                    drawPrimaryLine(g2, rendererState, series, item);
                }
            }
        } else if (isShapesAndLabelsPass(pass)) {
            // second pass adds shapes and labels where the items are ..
            Shape entityArea = createHotSpotArea(plot, previousItemX, previousItemY, currentItemX, currentItemY,
                    nextItemX, nextItemY, zeroRangePoint);

            if (getItemShapeVisible(series, item)) {
                Shape shape = getItemShape(series, item);

                if (isVerticallyOrientedPlot) {
                    shape = ShapeUtilities.createTranslatedShape(shape, currentItemX, currentItemY);
                } else if (isHorizontallyOrientedPlot) {
                    shape = ShapeUtilities.createTranslatedShape(shape, currentItemY, currentItemX);
                }
                entityArea = shape;

                if (shape.intersects(dataArea)) {
                    if (getItemShapeFilled(series, item)) {
                        if (getUseFillPaint()) {
                            g2.setPaint(getItemFillPaint(series, item));
                        } else {
                            g2.setPaint(getItemPaint(series, item));
                        }
                        g2.fill(shape);
                    }

                    if (getDrawOutlines()) {
                        if (getUseOutlinePaint()) {
                            g2.setPaint(getItemOutlinePaint(series, item));
                        } else {
                            g2.setPaint(getItemPaint(series, item));
                        }

                        g2.setStroke(getItemOutlineStroke(series, item));
                    }

                    g2.draw(shape);
                }
            }

            if (isItemLabelVisible(series, item)) {
                // draw the item label if there is one...
                drawLabel(g2, dataSet, series, item, currentItemX, currentItemY, (yValue < 0.0), orientation);
            }

            int domainAxisIndex = plot.getDomainAxisIndex(domainAxis);
            int rangeAxisIndex = plot.getRangeAxisIndex(rangeAxis);
            updateCrosshairValues(crosshairState, xValue, yValue, domainAxisIndex,
                    rangeAxisIndex, currentItemX, currentItemY, orientation);

            // collect entity and tool tip information...
            EntityCollection entities = state.getEntityCollection();
            if (entities != null && entityArea != null) {
                addEntity(entities, entityArea, dataSet, series, item, 0.0, 0.0);
            }
        }
    }

    public void completePass(Graphics2D g2, CategoryItemRendererState state, Rectangle2D dataArea, CategoryPlot plot,
                             CategoryAxis domainAxis, ValueAxis rangeAxis, CategoryDataset dataSet, int row, int pass) {
        // Do nothing for now
    }

    private void drawPrimaryLine(Graphics2D g2, XYLineAreaFillRendererState rendererState, int series, int item) {
        g2.setPaint(getItemPaint(series, item));
        g2.setStroke(getItemStroke(series, item));

        for (Line2D line : rendererState.lines) {
            g2.draw(line);
        }
    }

    private void drawLabel(Graphics2D g2, XYDataset dataSet, int series, int item,
                           double currentItemX, double currentItemY, boolean negative,
                           PlotOrientation orientation) {
        double labelX = (orientation == PlotOrientation.HORIZONTAL) ? currentItemY : currentItemX;
        double labelY = (orientation == PlotOrientation.HORIZONTAL) ? currentItemX : currentItemY;

        drawItemLabel(g2, orientation, dataSet, series, item, labelX, labelY, negative);
    }

    private void addItemLine(XYPlot plot, XYLineAreaFillRendererState rendererState,
                             double previousItemX, double previousItemY,
                             double currentItemX, double currentItemY) {

        if (plot.getOrientation() == PlotOrientation.VERTICAL) {
            rendererState.lines.add(new Line2D.Double(previousItemX, previousItemY, currentItemX, currentItemY));
        } else if (plot.getOrientation() == PlotOrientation.HORIZONTAL) {
            rendererState.lines.add(new Line2D.Double(previousItemY, previousItemX, currentItemY, currentItemX));
        }
    }

    private Polygon createHotSpotArea(XYPlot plot,
                                      double previousItemX, double previousItemY,
                                      double currentItemX, double currentItemY,
                                      double nextItemX, double nextItemY,
                                      double transZero) {
        Polygon hotSpot;
        if (plot.getOrientation() == PlotOrientation.HORIZONTAL) {
            hotSpot = new Polygon();

            hotSpot.addPoint((int) transZero,
                    (int) ((previousItemX + currentItemX) / 2.0));
            hotSpot.addPoint((int) ((previousItemY + currentItemY) / 2.0),
                    (int) ((previousItemX + currentItemX) / 2.0));
            hotSpot.addPoint((int) currentItemY, (int) currentItemX);
            hotSpot.addPoint((int) ((currentItemY + nextItemY) / 2.0),
                    (int) ((currentItemX + nextItemX) / 2.0));
            hotSpot.addPoint((int) transZero,
                    (int) ((currentItemX + nextItemX) / 2.0));
        } else {
            // vertical orientation
            hotSpot = new Polygon();

            hotSpot.addPoint((int) ((previousItemX + currentItemX) / 2.0),
                    (int) transZero);
            hotSpot.addPoint((int) ((previousItemX + currentItemX) / 2.0),
                    (int) ((previousItemY + currentItemY) / 2.0));
            hotSpot.addPoint((int) currentItemX, (int) currentItemY);
            hotSpot.addPoint((int) ((currentItemX + nextItemX) / 2.0),
                    (int) ((currentItemY + nextItemY) / 2.0));
            hotSpot.addPoint((int) ((currentItemX + nextItemX) / 2.0),
                    (int) transZero);
        }
        return hotSpot;
    }


    private double calculateItemXPoint(int series, int item, Rectangle2D dataArea,
                                       ValueAxis domainAxis,
                                       XYDataset dataSet, XYPlot plot) {
        double xValue = dataSet.getXValue(series, item);
        return domainAxis.valueToJava2D(xValue, dataArea, plot.getDomainAxisEdge());
    }

    private double calculateItemYPoint(int series, int item, Rectangle2D dataArea,
                                       ValueAxis rangeAxis,
                                       XYDataset dataSet, XYPlot plot) {
        double yValue = dataSet.getYValue(series, item);
        return rangeAxis.valueToJava2D(yValue, dataArea, plot.getRangeAxisEdge());
    }

    /**
     * Returns <code>true</code> if the specified pass is the one for drawing
     * lines.
     *
     * @param pass the pass.
     * @return A boolean.
     */
    protected boolean isAreaAndLinePass(int pass) {
        return pass == 0;
    }

    /**
     * Returns <code>true</code> if the specified pass is the one for drawing
     * items.
     *
     * @param pass the pass.
     * @return A boolean.
     */
    protected boolean isShapesAndLabelsPass(int pass) {
        return pass == 1;
    }


    @Override
    public Paint getItemOutlinePaint(int row, int column) {
        final Paint itemOutlinePaint = delegate.getItemOutlinePaint(row, column);
        if (itemOutlinePaint != null) {
            return itemOutlinePaint;
        }

        return super.getItemOutlinePaint(row, column);
    }

    @Override
    public Stroke getItemOutlineStroke(int row, int column) {
        final Stroke outlineStroke = delegate.getItemOutlineStroke(row, column);
        if (outlineStroke != null) {
            return outlineStroke;
        }

        return super.getItemOutlineStroke(row, column);
    }

    @Override
    public Paint getItemPaint(int row, int column) {
        final Paint itemPaint = delegate.getItemPaint(row, column);
        if (itemPaint != null) {
            return itemPaint;
        }

        return super.getItemPaint(row, column);
    }

    public void setItemOutlinePaint(int row, int column, Paint paint) {
        delegate.setItemOutlinePaint(row, column, paint);
    }

    public void setItemOutlineStroke(int row, int column, Stroke stroke) {
        delegate.setItemOutlineStroke(row, column, stroke);
    }

    public void setItemPaint(int row, int column, Paint paint) {
        delegate.setItemPaint(row, column, paint);
    }

    /**
     * Returns a clone of the renderer.
     *
     * @return A clone.
     * @throws CloneNotSupportedException if the renderer cannot be cloned.
     */
    public Object clone() throws CloneNotSupportedException {
        XYLineAreaFillRenderer clone = (XYLineAreaFillRenderer) super.clone();
        clone.legendLine = ShapeUtilities.clone(this.legendLine);
        return clone;
    }

    /**
     * Tests this renderer for equality with an arbitrary object.
     *
     * @param obj the object (<code>null</code> permitted).
     * @return A boolean.
     */
    public boolean equals(Object obj) {
        if (obj == this) {
            return true;
        }
        if (!(obj instanceof XYLineAreaFillRenderer)) {
            return false;
        }
        XYLineAreaFillRenderer that = (XYLineAreaFillRenderer) obj;
        if (this.drawFilledArea != that.drawFilledArea) {
            return false;
        }
        if (!ObjectUtilities.equal(this.seriesLinesVisible, that.seriesLinesVisible)) {
            return false;
        }
        if (this.baseLinesVisible != that.baseLinesVisible) {
            return false;
        }
        if (!ObjectUtilities.equal(this.seriesShapesVisible, that.seriesShapesVisible)) {
            return false;
        }
        if (this.baseShapesVisible != that.baseShapesVisible) {
            return false;
        }
        if (!ObjectUtilities.equal(this.seriesShapesFilled, that.seriesShapesFilled)) {
            return false;
        }
        if (this.baseShapesFilled != that.baseShapesFilled) {
            return false;
        }
        if (this.drawOutlines != that.drawOutlines) {
            return false;
        }
        if (this.useOutlinePaint != that.useOutlinePaint) {
            return false;
        }
        if (this.useFillPaint != that.useFillPaint) {
            return false;
        }
        if (this.drawOutlines != that.drawOutlines) {
            return false;
        }
        if (!ShapeUtilities.equal(this.legendLine, that.legendLine)) {
            return false;
        }

        return true;
    }

    /**
     * Provides serialization support.
     *
     * @param stream the input stream.
     * @throws java.io.IOException    if there is an I/O error.
     * @throws ClassNotFoundException if there is a classpath problem.
     */
    private void readObject(ObjectInputStream stream)
            throws IOException, ClassNotFoundException {
        stream.defaultReadObject();
        this.legendLine = SerialUtilities.readShape(stream);
    }

    /**
     * Provides serialization support.
     *
     * @param stream the output stream.
     * @throws IOException if there is an I/O error.
     */
    private void writeObject(ObjectOutputStream stream) throws IOException {
        stream.defaultWriteObject();
        SerialUtilities.writeShape(this.legendLine, stream);
    }
}
